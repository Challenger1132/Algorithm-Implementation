package hw_1;

/* 有n对括号()，总的排列数为C(2n, n)，中间有非法的排列，非法排列是右括号),比左括号(多一个前缀的情况
 * ( 用1表示， ) 用-1表示，一个排列可以看做是一个数组
 * 合法的排列数有C(2n, n) / (n+1)
 * 卡特兰数：
 * 1、n对括号排列，合法的排列数有多少种
 * 2、n个元素就进栈，元素出栈有多少种
 * 3、n个无差别节点构成的二叉树种类，f(0) = 1，代表0个节点，是空树
 * 	n个元素排成一排，第1个节点作为根节点可以将n个节点分为左边0个节点，右边n-1个节点，种类数是f(0)*f(n-1)
 * 	第2个节点作为根节点可以将n个节点分为左边1个节点，右边n-2个节点，种类数是f(1)*f(n-2)
 *  第3个节点作为根节点可以将n个节点分为左边2个节点，右边n-3个节点，种类数是f(3)*f(n-3)
 *  ...
 *  总的数目是f(0)*f(n-1) + f(1)*f(n-2) + f(2)*f(n-3) + ... + f(n-1)*f(0) = C(2n, n) / (n+1)
 * 和出栈之后某个元素在几号位置是一样的，n个元素出栈之后排成一列
 * 假设某个元素在1号位置可以将n个元素分为前面0个元素，后面n-1个元素情况，分别是f(0)和f(n-1)
 * 某个元素在2号位置可以将n个元素分为前面1个元素，后面n-2个元素情况，分别是f(1)和f(n-2)
 * 总的出栈数目是f(0)*f(n-1) + f(1)*f(n-2) + f(2)*f(n-3) + ... + f(n-1)*f(0) = C(2n, n) / (n+1)
 * f(0) = 1,
 * f(1) = 1,
 * f(2) = 2,
 * f(3) = 5,
 * f(n) = f(0)*f(n-1) + f(1)*f(n-2) + f(2)*f(n-3) + ... + f(n-1)*f(0)
 * 就可以用卡特兰数公式解决C(2n, n) / (n+1) = C(2n, n) - C(2n, n+1) 
 * 
 * 
 * */
public class Brackets2 {

}
